[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Optimization & Applications",
    "section": "",
    "text": "üéØ Course Vision & Context",
    "crumbs": [
      "üéØ Course Vision & Context"
    ]
  },
  {
    "objectID": "index.html#course-syllabus-48-hours-12-weeks",
    "href": "index.html#course-syllabus-48-hours-12-weeks",
    "title": "Computational Optimization & Applications",
    "section": "Course Syllabus (48 Hours / 12 Weeks)",
    "text": "Course Syllabus (48 Hours / 12 Weeks)\n\nCourse Overview\nCourse Code: 20MAT382\nCourse Name: Computational Optimization and Applications\nDuration: 12 Weeks (4 hours/week)\nCredits: 4\nTotal Marks: 150 (Internal: 70 + External: 80)\n\nIntensive Learning Approach\nAccelerated project-based curriculum focusing on core optimization concepts with immediate practical application through integrated micro-projects.\n\n\n\nCourse Objectives\n\n\n\n\n\n\n\nS.No\nCOURSE OBJECTIVES\n\n\n\n\n1\nTo gain a comprehensive understanding of optimization concepts and their real-world relevance, emphasizing Python as a practical tool for optimization.\n\n\n2\nTo develop proficiency in Python for optimization, including formulating and solving linear programming problems, implementing nonlinear optimization and analysing optimization solutions.\n\n\n3\nTo acquire skills in project planning and optimization techniques using Python.\n\n\n4\nTo master optimization techniques in the context of machine learning, including Gradient Descent, Stochastic Gradient Descent, and various optimization algorithms, all implemented in Python.\n\n\n5\nTo apply optimization knowledge and Python skills to solve combinatorial and graph-based problems, while also considering the ethical aspects of optimization in engineering, logistics, and decision-making.",
    "crumbs": [
      "üéØ Course Vision & Context"
    ]
  },
  {
    "objectID": "index.html#course-outcomes",
    "href": "index.html#course-outcomes",
    "title": "Computational Optimization & Applications",
    "section": "Course Outcomes",
    "text": "Course Outcomes\nAt the end of the course students will be able to:\n\n\n\n\n\n\n\n\nCO Code\nCOURSE OUTCOMES\nREVISED BLOOM‚ÄôS TAXONOMY LEVEL\n\n\n\n\nCO1\nDemonstrate a thorough understanding of optimization concepts, problem types, and their real-world applications.\n3\n\n\nCO2\nFormulate and solve linear programming problems using Python.\n3\n\n\nCO3\nImplement nonlinear optimization algorithms, and analyse optimization solutions using Python.\n2\n\n\nCO4\nDevelop practical project planning skills and proficiency in applying heuristic algorithms to real-world scenarios.\n2\n\n\nCO5\nDemonstrate mastery of optimization in Machine Learning, with the ability to apply Gradient Descent, Stochastic Gradient Descent.\n3\n\n\n\n\nCore Competencies\n\nFormulate real-world problems as mathematical optimization models\nImplement optimization algorithms in Python using industry tools\nAnalyze and validate optimization solutions\nDevelop end-to-end optimization systems for practical applications\n\n\n\nAssessment Plan (70 Marks Internal)\n\nContinuous Evaluation (70 Marks)\nA. Theory Components (20 Marks)\n\nInternal Exam 1: 10 marks (Week 6)\nInternal Exam 2: 10 marks (Week 12)\n\nB. Practical Components (50 Marks)\n\nAssignments/Micro Projects: 15 marks (3 projects √ó 5 marks each)\nLab Exams: 10 marks (2 exams √ó 5 marks each)\nDay-to-Day Lab Work: 15 marks\nAttendance: 10 marks\n\n\n\nExternal Examination (80 Marks)\n\nEnd Semester Theory Exam: 80 marks\n\n\n\n\nüóìÔ∏è 12-Week Delivery Plan (4 Hours/Week)\n\nPhase 1: Foundation & Linear Methods (Weeks 1-4)\nWeek 1: Optimization Fundamentals & Python Setup (4 hours)\n\nTheory (2h): Optimization concepts, problem classification, LP formulation\nLab (2h): Python environment setup, PuLP introduction\nLab Work: Basic LP implementation (1 mark)\nMicro-Project 1 Launch: Campus facility location problem\n\nWeek 2: Linear Programming & Solution Methods (4 hours)\n\nTheory (2h): Graphical method, Simplex algorithm\nLab (2h): PuLP implementation, constraint handling\nLab Work: Complex constraint implementation (1 mark)\nAttendance: Week 1-2 (2 marks)\n\nWeek 3: Advanced LP & Real Applications (4 hours)\n\nTheory (1h): Sensitivity analysis, duality\nLab (3h): Transportation problems, case studies\nLab Work: Transportation problem solution (1 mark)\nMicro-Project 1 Due: Submission (5 marks)\n\nWeek 4: Nonlinear Optimization Foundations (4 hours)\n\nTheory (2h): Unconstrained optimization, Golden Section\nLab (2h): SciPy optimization, function minimization\nLab Work: Nonlinear solver implementation (1 mark)\nAttendance: Week 3-4 (2 marks)\n\n\n\nPhase 2: Constrained & Combinatorial Methods (Weeks 5-8)\nWeek 5: Constrained Optimization (4 hours)\n\nTheory (2h): KKT conditions, constraint handling\nLab (2h): Constrained NLP implementation\nLab Work: KKT condition implementation (1 mark)\nMicro-Project 2 Launch: Nonlinear cost optimization\nLab Exam 1: Basic LP/NLP implementation (5 marks)\n\nWeek 6: Project Planning & Heuristics (4 hours)\n\nTheory (1h): CPM/PERT fundamentals\nLab (3h): Project scheduling, greedy algorithms\nInternal Exam 1: Theory assessment (10 marks)\nLab Work: Project scheduling implementation (1 mark)\n\nWeek 7: Graph Algorithms I (4 hours)\n\nTheory (1h): Graph theory, shortest path concepts\nLab (3h): NetworkX implementation, Dijkstra‚Äôs algorithm\nLab Work: Shortest path implementation (1 mark)\nMicro-Project 2 Due: Submission (5 marks)\nAttendance: Week 5-7 (2 marks)\n\nWeek 8: Graph Algorithms II (4 hours)\n\nTheory (1h): MST, network flows, TSP overview\nLab (3h): Advanced graph algorithms\nLab Work: MST implementation (1 mark)\nMicro-Project 3 Launch: Routing optimization\n\n\n\nPhase 3: Advanced Applications & Integration (Weeks 9-12)\nWeek 9: Machine Learning Optimization I (4 hours)\n\nTheory (2h): Gradient Descent, SGD, optimization in ML\nLab (2h): Basic GD implementation\nLab Work: Gradient descent implementation (1 mark)\nAttendance: Week 8-9 (2 marks)\n\nWeek 10: Machine Learning Optimization II (4 hours)\n\nTheory (1h): Advanced optimizers, neural networks\nLab (3h): TensorFlow/PyTorch optimization\nLab Work: Advanced optimizer implementation (1 mark)\nLab Exam 2: Graph and ML optimization (5 marks)\n\nWeek 11: Integrated Applications (4 hours)\n\nWorkshop (4h): Comprehensive system implementation\nLab Work: Integrated system development (2 marks)\nMicro-Project 3 Due: Submission (5 marks)\n\nWeek 12: Review & Final Assessment (4 hours)\n\nInternal Exam 2: Theory assessment (10 marks)\nCourse Review: Comprehensive concepts revision\nLab Work: Final implementation polish (1 mark)\nAttendance: Week 10-12 (2 marks)\n\n\n\n\nThematic Project: Campus City Supply Chain\n\nMicro-Projects (15 Marks Total)\nMicro-Project 1: Basic LP Implementation (5 marks)\n\nTimeline: Week 1-3\nScope: 6 facilities, 3 warehouses, linear costs\nAssessment: Model correctness (2), Code quality (2), Documentation (1)\n\nMicro-Project 2: Nonlinear Optimization (5 marks)\n\nTimeline: Week 4-7\nScope: Enhanced cost models, KKT conditions\nAssessment: Algorithm implementation (2), Analysis (2), Validation (1)\n\nMicro-Project 3: Graph & Network Optimization (5 marks)\n\nTimeline: Week 8-11\nScope: Routing, shortest paths, resource allocation\nAssessment: System design (2), Performance (2), Documentation (1)\n\n\n\n\nDetailed Mark Distribution\n\nDay-to-Day Lab Work (15 Marks)\n\nWeekly Implementation Tasks: 12 marks (1 mark √ó 12 weeks)\nIntegrated System Development: 3 marks (Week 11)\n\n\n\nAttendance (10 Marks)\n\nWeekly Attendance: 2 marks per 3-week block\nFull Attendance Bonus: 2 marks for 100% attendance\n\n\n\nLab Exams (10 Marks)\n\nLab Exam 1 (Week 5): Basic LP/NLP implementation (5 marks)\nLab Exam 2 (Week 10): Graph and ML optimization (5 marks)\n\n\n\nInternal Exams (20 Marks)\n\nInternal Exam 1 (Week 6): Modules 1-2 theory (10 marks)\nInternal Exam 2 (Week 11): Modules 3-4 theory (10 marks)\n\n\n\n\nLearning Outcomes Mapping\n\nTheory Outcomes (Internal Exams + External)\n\nFormulate optimization problems mathematically\nUnderstand algorithm properties and convergence\nAnalyze problem structures and solution methods\n\n\n\nPractical Outcomes (Lab Work + Projects)\n\nImplement optimization algorithms in Python\nDevelop end-to-end optimization systems\nValidate and analyze optimization results\nCreate professional documentation and visualizations\n\n\n\n\nGrading Rubrics\n\nMicro-Projects (5 marks each)\n\nExcellent (5): Flawless implementation with advanced features\nVery Good (4): Correct implementation with good documentation\nGood (3): Basic functionality with minor issues\nSatisfactory (2): Meets minimum requirements\nPoor (1): Significant functionality missing\n\n\n\nLab Work (Weekly 1 mark)\n\nComplete (1): Task fully implemented and demonstrated\nPartial (0.5): Basic implementation with issues\nIncomplete (0): Task not attempted or completely non-functional\n\n\n\nLab Exams (5 marks each)\n\nAlgorithm Implementation: 2 marks\nProblem Solving: 2 marks\nCode Quality: 1 mark\n\n\n\n\nSuccess Strategy\n\nMaximizing Internal Marks\n\nConsistent Attendance: 10 marks easily achievable\nRegular Lab Work: 15 marks through weekly completion\nQuality Projects: 15 marks with careful implementation\nLab Exam Preparation: 10 marks with practice\nInternal Exam Focus: 20 marks through concept mastery\n\n\n\nExternal Exam Preparation (80 Marks)\n\nComprehensive theory coverage from all modules\nProblem-solving practice with various optimization types\nMathematical formulation skills\nAlgorithm analysis and comparison\n\n\n\n\nWeekly Preparation Guide\n\nBefore Each Week\n\nReview weekly objectives and deliverables\nPrepare development environment\nRead theoretical concepts in advance\n\n\n\nDuring Each Week\n\nAttend all sessions (critical for attendance marks)\nComplete lab work during sessions\nStart micro-projects early\nSeek clarification immediately\n\n\n\nAfter Each Week\n\nSubmit all lab work promptly\nReview concepts for internal exams\nPrepare for upcoming assessments\nMaintain code repository\n\n\nThis assessment-focused syllabus ensures students can maximize their 70 internal marks through consistent performance while preparing comprehensively for the 80-mark external examination. The structured approach balances theoretical understanding with practical implementation skills.",
    "crumbs": [
      "üéØ Course Vision & Context"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1¬† Introduction to Computational Optimization and Applications",
    "section": "",
    "text": "1.1 Why Optimization Matters Now More Than Ever\nThe exponential growth in data complexity and computational requirements has transformed optimization from a theoretical discipline to an essential toolkit for every computer scientist and data professional. Consider these real-world contexts:",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction to Computational Optimization and Applications</span>"
    ]
  },
  {
    "objectID": "intro.html#why-optimization-matters-now-more-than-ever",
    "href": "intro.html#why-optimization-matters-now-more-than-ever",
    "title": "1¬† Introduction to Computational Optimization and Applications",
    "section": "",
    "text": "AI Systems: Training neural networks is essentially an optimization process (Gradient Descent)\nOperations Research: Logistics, scheduling, and resource allocation drive billion-dollar efficiencies\n\nData Science: Model selection, hyperparameter tuning, and feature engineering are optimization problems\nAutonomous Systems: Path planning, control systems, and decision-making rely on optimization algorithms\nQuantum Computing: Many quantum algorithms are designed to solve optimization problems more efficiently",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction to Computational Optimization and Applications</span>"
    ]
  },
  {
    "objectID": "intro.html#programme-objectives-learning-outcomes",
    "href": "intro.html#programme-objectives-learning-outcomes",
    "title": "1¬† Introduction to Computational Optimization and Applications",
    "section": "1.2 üìã Programme Objectives & Learning Outcomes",
    "text": "1.2 üìã Programme Objectives & Learning Outcomes\n\n1.2.1 Core Educational Mission\nThis minor programme is designed to bridge the critical gap between theoretical optimization mathematics and practical computational implementation. Upon successful completion, you will be able to:\n\n\n\n\n\n\n\nDomain\nLearning Outcomes\n\n\n\n\nTheoretical Foundation\n‚Ä¢ Formulate real-world problems as mathematical optimization models‚Ä¢ Understand optimality conditions and convergence properties‚Ä¢ Analyze problem structures to select appropriate solution methods\n\n\nComputational Skills\n‚Ä¢ Implement classical and modern optimization algorithms in Python‚Ä¢ Utilize industry-standard optimization libraries and frameworks‚Ä¢ Develop end-to-end optimization pipelines for practical applications\n\n\nAI/ML Integration\n‚Ä¢ Understand optimization‚Äôs role in training machine learning models‚Ä¢ Implement gradient-based methods for neural network optimization‚Ä¢ Apply optimization to hyperparameter tuning and model selection\n\n\nProblem-Solving\n‚Ä¢ Design optimization solutions for complex, multi-objective problems‚Ä¢ Evaluate solution quality and algorithm performance‚Ä¢ Communicate optimization insights to technical and non-technical stakeholders\n\n\n\n\n\n1.2.2 The ‚ÄúSmart City Logistics‚Äù Experiential Thread\nThroughout this course, we‚Äôll employ a continuous practical thread: optimizing logistics and operations for a smart city ecosystem. This narrative provides:\n\nReal-world context for theoretical concepts\nProgressive complexity as we advance through modules\nPortfolio-building implementation experience\nIndustry-relevant problem-solving skills\n\nSmart City Optimization Journey:\n\nModule 1: Warehouse Location (Linear Programming)\nModule 2: Fuel Cost Optimization (Nonlinear Programming)\nModule 3: Delivery Routing (Graph Algorithms)\nModule 4: Dynamic Scheduling (Heuristic Methods)\nModule 5: Demand Prediction (ML Integration)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction to Computational Optimization and Applications</span>"
    ]
  },
  {
    "objectID": "intro.html#course-roadmap-syllabus-integration",
    "href": "intro.html#course-roadmap-syllabus-integration",
    "title": "1¬† Introduction to Computational Optimization and Applications",
    "section": "1.3 Course Roadmap & Syllabus Integration",
    "text": "1.3 Course Roadmap & Syllabus Integration\n\n1.3.1 Module Progression: From Foundations to Frontiers\nOur journey through computational optimization is strategically sequenced to build from fundamental principles to advanced applications:\n\n1.3.1.1 Foundation Phase: Mathematical Underpinnings\n\nModule I: Linear Programming & Formulation Skills\nModule II: Nonlinear Optimization & Constraint Handling\n\n\n\n1.3.1.2 Advanced Phase: Algorithmic Thinking\n\nModule III: Project Planning & Heuristic Methods\nModule IV: Combinatorial & Graph Optimization\n\n\n\n1.3.1.3 Integration Phase: AI/ML Applications\n\nModule V: Gradient Methods & Machine Learning Optimization\n\n\n\n\n1.3.2 Assessment Strategy: Theory Meets Practice\nTo ensure comprehensive understanding and skill development, assessment integrates both theoretical knowledge and practical implementation:\n\nSeries Examinations: Test conceptual understanding and problem formulation\nPractical Assignments/ Micro Project: Evaluate implementation skills and computational thinking\n\nFinal Project: Assess integrated problem-solving and solution design\nContinuous Evaluation: Monitor progress through micro-projects and code reviews",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction to Computational Optimization and Applications</span>"
    ]
  },
  {
    "objectID": "intro.html#optimization-in-the-aiml-ecosystem",
    "href": "intro.html#optimization-in-the-aiml-ecosystem",
    "title": "1¬† Introduction to Computational Optimization and Applications",
    "section": "1.4 Optimization in the AI/ML Ecosystem",
    "text": "1.4 Optimization in the AI/ML Ecosystem\n\n1.4.1 The Central Role in Machine Learning\nOptimization isn‚Äôt just adjacent to machine learning‚Äîit is machine learning. The entire process of training machine learning models revolves around optimization principles:\n\nLoss Minimization: Finding model parameters that minimize prediction error\nConvergence Analysis: Understanding when and how algorithms reach optimal solutions\nRegularization: Balancing model complexity with performance through constrained optimization\nHyperparameter Tuning: Optimizing the optimization process itself\n\n\n\n1.4.2 Emerging Trends & Future Directions\nThe field of optimization is rapidly evolving, driven by advances in:\n\nLarge-Scale Optimization: Methods for billion-parameter models in deep learning\nAutomated Optimization: AutoML and neural architecture search\nQuantum Optimization: Quantum annealing and hybrid quantum-classical algorithms\n\nFederated Optimization: Privacy-preserving distributed learning\nMulti-Objective Optimization: Pareto optimization for conflicting objectives\nExplainable Optimization: Interpretable and transparent optimization processes",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction to Computational Optimization and Applications</span>"
    ]
  },
  {
    "objectID": "intro.html#technical-ecosystem-tools",
    "href": "intro.html#technical-ecosystem-tools",
    "title": "1¬† Introduction to Computational Optimization and Applications",
    "section": "1.5 Technical Ecosystem & Tools",
    "text": "1.5 Technical Ecosystem & Tools\n\n1.5.1 Why Python for Optimization?\nPython has emerged as the lingua franca for computational optimization due to:\n\nRich Ecosystem: Comprehensive libraries for every optimization paradigm\nAI/ML Integration: Seamless connection with machine learning frameworks\nPerformance: C/Fortran-backed numerical computing with Python simplicity\nCommunity: Vibrant ecosystem with continuous algorithm development\nIndustry Adoption: Widely used in both academia and industry\n\n\n\n1.5.2 Core Toolchain\nThroughout this course, we‚Äôll work with industry-standard tools:\nOur Computational Optimization Stack:\n\n\n\nCategory\nTools\n\n\n\n\nNumerical Computing\nNumPy, SciPy\n\n\nLinear Programming\nPuLP, CVXPY\n\n\nMachine Learning\nScikit-learn, TensorFlow, PyTorch\n\n\nGraph Algorithms\nNetworkX\n\n\nVisualization\nMatplotlib, Plotly, Seaborn\n\n\nDevelopment\nJupyter, VSCode, Git",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction to Computational Optimization and Applications</span>"
    ]
  },
  {
    "objectID": "intro.html#getting-started-your-learning-journey",
    "href": "intro.html#getting-started-your-learning-journey",
    "title": "1¬† Introduction to Computational Optimization and Applications",
    "section": "1.6 Getting Started: Your Learning Journey",
    "text": "1.6 Getting Started: Your Learning Journey\n\n1.6.1 Prerequisites & Preparation\nTo succeed in this course, you should have:\n\nProgramming Fundamentals: Basic Python proficiency\nMathematical Background: Linear algebra and calculus foundations\n\nComputational Mindset: Willingness to experiment and debug\nProblem-Solving Attitude: Persistence through challenging concepts\nCuriosity and Creativity: Interest in exploring multiple solution approaches\n\n\n\n1.6.2 How to Maximize Your Learning\n\nEngage Actively: Don‚Äôt just read‚Äîimplement every concept in code\nThink Critically: Question why certain methods work better for specific problems\nExperiment Freely: Modify parameters, break code, and learn from failures\nConnect Concepts: Relate theoretical principles to practical implementations\nBuild Portfolio: Document your work for future career opportunities\nCollaborate Effectively: Learn from peers through code reviews and discussions\nStay Updated: Follow recent developments in optimization research\n\n\n\n1.6.3 Course Structure and Expectations\nThis course is designed as a blended learning experience combining:\n\nTheoretical Foundations: Mathematical principles and algorithm concepts\nPractical Implementation: Hands-on coding exercises and projects\nReal-World Applications: Industry-relevant case studies and problems\nAssessment and Feedback: Continuous evaluation and improvement",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction to Computational Optimization and Applications</span>"
    ]
  },
  {
    "objectID": "intro.html#welcome-to-the-journey",
    "href": "intro.html#welcome-to-the-journey",
    "title": "1¬† Introduction to Computational Optimization and Applications",
    "section": "1.7 üåü Welcome to the Journey",
    "text": "1.7 üåü Welcome to the Journey\nYou are beginning a journey into one of the most fundamental and powerful domains of computer science and artificial intelligence. The skills you develop here will serve as a foundation for advanced work in machine learning, operations research, data science, and algorithmic design.\nAs we progress through the modules, remember that each concept builds toward a comprehensive understanding of how to make computers not just compute, but optimize‚Äîtransforming them from calculators into intelligent decision-makers.\nThe journey through computational optimization is challenging but immensely rewarding. You‚Äôll gain not just technical skills, but a new way of thinking about problem-solving that will serve you throughout your career in technology.\n\n‚ÄúOptimization is the science of better. In a world of limited resources and unlimited wants, optimization provides the mathematical foundation for making the best possible decisions.‚Äù",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction to Computational Optimization and Applications</span>"
    ]
  },
  {
    "objectID": "Module-1.html",
    "href": "Module-1.html",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "",
    "text": "2.1 Module Overview",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  },
  {
    "objectID": "Module-1.html#module-overview",
    "href": "Module-1.html#module-overview",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "",
    "text": "2.1.1 Learning Objectives\n\nUnderstand fundamental optimization concepts and problem classification\nFormulate real-world problems as Linear Programming models\nSolve LP problems using graphical and computational methods\nImplement LP solutions in Python for practical applications\nApply optimization thinking to facility location problems\n\n\n\n2.1.2 Smart City Context: Warehouse Location Challenge\nIn our Smart City Logistics project, we face a critical business decision: where to locate new distribution warehouses to minimize transportation costs while serving all city facilities efficiently. This module provides the mathematical foundation to solve this strategic problem.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  },
  {
    "objectID": "Module-1.html#foundations-of-optimization",
    "href": "Module-1.html#foundations-of-optimization",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "2.2 Foundations of Optimization",
    "text": "2.2 Foundations of Optimization\n\n2.2.1 What is Optimization?\nOptimization is the science of finding the best possible solution from all feasible alternatives under given constraints. In computational terms, it involves:\n\nDecision Variables: Quantities we can control (e.g., warehouse locations, shipment quantities)\nObjective Function: What we want to maximize or minimize (e.g., total transportation cost)\nConstraints: Limitations and requirements (e.g., budget, capacity, demand)\n\n\n\n2.2.2 Optimization Problem Classification\n\n\n\n\n\n\n\n\nProblem Type\nCharacteristics\nSmart City Example\n\n\n\n\nLinear Programming\nLinear objective and constraints\nWarehouse location with fixed costs\n\n\nNonlinear Programming\nNonlinear relationships\nFuel costs that increase with distance\n\n\nConstrained Optimization\nWith limitations\nBudget constraints on construction\n\n\nUnconstrained Optimization\nNo limitations\nTheoretical ideal locations\n\n\nDiscrete Optimization\nInteger decisions\nYes/no decisions for locations\n\n\nContinuous Optimization\nReal-valued decisions\nPrecise coordinates for facilities\n\n\n\n\n\n2.2.3 Real-World Applications in CSE\n\nResource Allocation: CPU time, memory allocation in operating systems\nNetwork Optimization: Internet routing, data flow optimization\nMachine Learning: Model training via loss function minimization\nDatabase Systems: Query optimization and indexing\nComputer Graphics: Rendering optimization and path tracing",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  },
  {
    "objectID": "Module-1.html#basic-python-for-optimization",
    "href": "Module-1.html#basic-python-for-optimization",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "2.3 Basic Python for Optimization",
    "text": "2.3 Basic Python for Optimization\n\n2.3.1 Essential Python Libraries Setup\n\n# Core optimization stack installation\n# pip install numpy scipy matplotlib pulp pandas jupyter\n\n\n\n\n\n\n\nKey Python Libraries Required for Computational Part\n\n\n\n\nNumPy: Numerical computing and array operations\nSciPy: Scientific computing and optimization algorithms\nMatplotlib: Data visualization and result plotting\nPuLP: Linear programming interface\nPandas: Data manipulation and analysis\n\n\n\n\n\n2.3.2 Python Fundamentals for Optimization\n\n# Essential operations we'll use frequently\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Array operations for constraint matrices\ncoefficients = np.array([[2, 1], [1, 3], [4, 2]])\n\n# Function definitions for objectives\ndef transportation_cost(warehouses, facilities):\n    return np.sum(warehouses * facilities)\n\n# Data handling for problem parameters\ndemand_data = {'Hospital': 50, 'School': 30, 'Mall': 80}",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  },
  {
    "objectID": "Module-1.html#linear-programming-fundamentals",
    "href": "Module-1.html#linear-programming-fundamentals",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "2.4 Linear Programming Fundamentals",
    "text": "2.4 Linear Programming Fundamentals\n\n2.4.1 Mathematical Definition of Linear Programming\nA Linear Programming (LP) problem can be formally defined as:\nObjective Function: \\[\n\\text{Optimize } Z = c_1x_1 + c_2x_2 + \\cdots + c_nx_n\n\\]\nSubject to Constraints:\n\\[\n\\begin{aligned}\na_{11}x_1 + a_{12}x_2 + \\cdots + a_{1n}x_n & \\leq b_1 \\\\\na_{21}x_1 + a_{22}x_2 + \\cdots + a_{2n}x_n & \\leq b_2 \\\\\n\\vdots & \\\\\na_{m1}x_1 + a_{m2}x_2 + \\cdots + a_{mn}x_n & \\leq b_m \\\\\n\\end{aligned}\n\\]\nNon-negativity Conditions:\n\\[\nx_1, x_2, \\ldots, x_n \\geq 0\n\\]\nWhere:\n\n\\(Z\\) is the objective function to be optimized (maximized or minimized)\n\\(x_1, x_2, \\ldots, x_n\\) are the decision variables\n\\(c_1, c_2, \\ldots, c_n\\) are the coefficients of the objective function\n\\(a_{ij}\\) are the technological coefficients\n\\(b_1, b_2, \\ldots, b_m\\) are the right-hand side constants\n\n\n\n2.4.2 Standard Forms of Linear Programming\n\n2.4.2.1 Canonical Form (Maximization)\n\\[\n\\begin{aligned}\n\\text{Maximize } & Z = \\mathbf{c}^T\\mathbf{x} \\\\\n\\text{Subject to } & \\mathbf{A}\\mathbf{x} \\leq \\mathbf{b} \\\\\n& \\mathbf{x} \\geq \\mathbf{0}\n\\end{aligned}\n\\]\n\n\n2.4.2.2 Standard Form (Maximization)\n\\[\n\\begin{aligned}\n\\text{Maximize } & Z = \\mathbf{c}^T\\mathbf{x} \\\\\n\\text{Subject to } & \\mathbf{A}\\mathbf{x} = \\mathbf{b} \\\\\n& \\mathbf{x} \\geq \\mathbf{0}\n\\end{aligned}\n\\]\n\n\n\n2.4.3 Key Concepts in Linear Programming\n\n2.4.3.1 Feasible Region\nThe set of all points that satisfy all constraints simultaneously: \\[\nF = \\{\\mathbf{x} \\in \\mathbb{R}^n : \\mathbf{A}\\mathbf{x} \\leq \\mathbf{b}, \\mathbf{x} \\geq \\mathbf{0}\\}\n\\]\n\n\n2.4.3.2 Optimal Solution\nA point \\(\\mathbf{x}^*\\) in the feasible region that gives the best value of the objective function.\n\n\n2.4.3.3 Corner Point (Extreme Point)\nA point in the feasible region that cannot be expressed as a convex combination of two other distinct points in the region.\n\n\n\n2.4.4 Smart City Case: Warehouse Location Formulation\n\n2.4.4.1 Problem Statement\nWe need to choose locations for 2 warehouses from 4 potential sites to serve 3 major facilities while minimizing total costs.\n\n\n2.4.4.2 Decision Variables\nLet: - \\(x_{ij}\\): Amount shipped from warehouse \\(i\\) to facility \\(j\\) - \\(y_i\\): Binary variable (1 if warehouse \\(i\\) is built, 0 otherwise)\nWhere: - \\(i = 1, 2, 3, 4\\) (warehouse sites) - \\(j = 1, 2, 3\\) (facilities: Hospital, Mall, School)\n\n\n2.4.4.3 Objective Function\nMinimize total cost: \\[\n\\text{Minimize } Z = \\sum_{i=1}^{4} \\sum_{j=1}^{3} c_{ij}x_{ij} + \\sum_{i=1}^{4} f_i y_i\n\\] Where: - \\(c_{ij}\\): Transportation cost per unit from warehouse \\(i\\) to facility \\(j\\) - \\(f_i\\): Fixed construction cost for warehouse \\(i\\)\n\n\n2.4.4.4 Constraints\nDemand Constraints (Each facility‚Äôs demand must be met): \\[\n\\sum_{i=1}^{4} x_{ij} = d_j \\quad \\text{for } j = 1,2,3\n\\] Where \\(d_j\\) is the demand of facility \\(j\\).\nCapacity Constraints (Warehouse capacity cannot be exceeded): \\[\n\\sum_{j=1}^{3} x_{ij} \\leq C_i y_i \\quad \\text{for } i = 1,2,3,4\n\\] Where \\(C_i\\) is the capacity of warehouse \\(i\\).\nBudget Constraint: \\[\n\\sum_{i=1}^{4} f_i y_i \\leq B\n\\] Where \\(B\\) is the total budget available.\nWarehouse Selection Constraint (Select exactly 2 warehouses): \\[\n\\sum_{i=1}^{4} y_i = 2\n\\]\nNon-negativity and Binary Requirements: \\[\nx_{ij} \\geq 0 \\quad \\text{for all } i,j\n\\] \\[\ny_i \\in \\{0, 1\\} \\quad \\text{for all } i\n\\]\n\n\n\n2.4.5 Graphical Method for Two-Variable Problems\n\n2.4.5.1 Step-by-Step Procedure\n\nPlot Constraints: Convert each inequality to equality and plot the line\nIdentify Feasible Region: Determine which side of each line satisfies the inequality\nFind Corner Points: Identify intersection points of constraint boundaries\nEvaluate Objective Function: Calculate objective value at each corner point\nIdentify Optimal Solution: Select the corner point with best objective value\n\n\n\n2.4.5.2 Example: Simple Warehouse Problem\nConsider a simplified version with 2 warehouses and 1 facility:\nProblem: \\[\n\\begin{aligned}\n\\text{Maximize } & Z = 40x_1 + 30x_2 \\\\\n\\text{Subject to } & 2x_1 + x_2 \\leq 100 \\\\\n& x_1 + 3x_2 \\leq 90 \\\\\n& x_1 \\geq 0, x_2 \\geq 0\n\\end{aligned}\n\\]\nStep 1: Plot Constraints - Constraint 1: \\(2x_1 + x_2 = 100\\) ‚Üí Line through (0,100) and (50,0) - Constraint 2: \\(x_1 + 3x_2 = 90\\) ‚Üí Line through (0,30) and (90,0)\nStep 2: Identify Corner Points - Intersection of axes: (0,0), (0,30), (50,0) - Intersection of constraints: Solve: \\[\n  \\begin{aligned}\n  2x_1 + x_2 &= 100 \\\\\n  x_1 + 3x_2 &= 90\n  \\end{aligned}\n\\] Solution: \\(x_1 = 42, x_2 = 16\\)\nStep 3: Evaluate Objective Function\n\nAt (0,0): \\(Z = 0\\)\nAt (0,30): \\(Z = 900\\)\nAt (50,0): \\(Z = 2000\\)\nAt (42,16): \\(Z = 40√ó42 + 30√ó16 = 2160\\)\n\nOptimal Solution: \\(x_1 = 42, x_2 = 16\\) with \\(Z = 2160\\)\n\n\n\n2.4.6 Simplex Method Theory\n\n2.4.6.1 Fundamental Theorem of Linear Programming\nIf an LP problem has an optimal solution, then there exists at least one corner point of the feasible region that is optimal.\n\n\n2.4.6.2 Simplex Algorithm Steps\n\nConvert to Standard Form\n\nConvert inequalities to equations using slack variables\nEnsure all variables are non-negative\nConvert minimization to maximization if needed\n\nInitial Basic Feasible Solution\n\nIdentify basic variables (variables with coefficient 1 in one equation and 0 in others)\nSet non-basic variables to zero\n\nOptimality Test\n\nCalculate reduced costs for non-basic variables\nIf all reduced costs \\(\\leq 0\\) (for maximization), current solution is optimal\n\nPivot Column Selection\n\nChoose non-basic variable with most positive reduced cost (for maximization)\n\nPivot Row Selection\n\nUse minimum ratio test: \\(\\min \\left\\{ \\frac{b_i}{a_{ij}} : a_{ij} &gt; 0 \\right\\}\\)\n\nPivot Operation\n\nMake pivot element equal to 1\nMake other elements in pivot column equal to 0\n\nRepeat until optimality condition is satisfied\n\n\n\n2.4.6.3 Simplex Tableau Format\nThe simplex method uses a tableau to organize calculations:\n\n\n\nBasic Var\n\\(x_1\\)\n\\(x_2\\)\n\\(s_1\\)\n\\(s_2\\)\nRHS\n\n\n\n\n\\(s_1\\)\n2\n1\n1\n0\n100\n\n\n\\(s_2\\)\n1\n3\n0\n1\n90\n\n\n\\(Z\\)\n-40\n-30\n0\n0\n0\n\n\n\nWhere \\(s_1, s_2\\) are slack variables.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  },
  {
    "objectID": "Module-1.html#types-of-linear-programming-solutions",
    "href": "Module-1.html#types-of-linear-programming-solutions",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "2.5 Types of Linear Programming Solutions",
    "text": "2.5 Types of Linear Programming Solutions\nWhen we feed a problem into a solver (like the Simplex algorithm), we usually expect a single, perfect answer. But algorithms are strict logicians. If we ask for the impossible or the infinite, they will tell us exactly that. In Linear Programming, there are four distinct outcomes.\n\n2.5.1 Unique Optimal Solution\nThe ‚ÄúIdeal‚Äù Scenario\nThis is the standard result. Geometrically, the feasible region is a polygon, and the Objective Function (the ‚Äúslope‚Äù of profit or cost) cuts through the region such that it touches exactly one corner point (vertex) last.\n\nMathematical Context: The slope of the objective function does not match the slope of any binding constraint.\nEngineering Implication: There is exactly one best way to allocate your resources. Any deviation from this plan results in lower profit or higher cost.\n\n\n\n2.5.2 Multiple Optimal Solutions (Alternative Optima)\nThe ‚ÄúFlexibility‚Äù Scenario\nSometimes, you might get a result where the solver says: ‚ÄúYou can choose Point A (\\(x=2, y=5\\)) or Point B (\\(x=4, y=3\\)), and the profit is exactly the same.‚Äù\n\nWhy this happens: The slope of your Objective Function is parallel to one of the binding constraint lines. Instead of touching a single corner, the objective function lies flat against an entire edge of the feasible region.\nEngineering Implication: This is actually great news for a designer! It means you have flexibility. Mathematically, the cost is the same, but maybe Plan A is politically easier to implement than Plan B. You can choose based on secondary factors (like aesthetics or risk) without losing optimality.\n\n\n\n2.5.3 Unbounded Solution\nThe ‚ÄúToo Good to Be True‚Äù Scenario\nImagine writing a program to maximize profit, and the output is Infinity. While exciting, this is invariably a modeling error.\n\nWhy this happens: The feasible region is not closed (it extends infinitely in one direction), and you are trying to maximize in that direction. You have forgotten a constraint.\nReal-world Example: ‚ÄúMaximize production.‚Äù If you don‚Äôt add a constraint for ‚ÄúAvailable Raw Materials‚Äù or ‚ÄúFactory Capacity,‚Äù the math assumes you can produce infinite units.\nMathematical Check: In the Simplex tableau, this occurs when a variable can enter the basis, but no variable leaves (no positive ratio in the pivot test).\n\n\n\n2.5.4 Infeasible Problem\nThe ‚ÄúImpossible‚Äù Scenario\nThis is the most common frustration in real-world engineering. You hit ‚ÄúRun,‚Äù and the solver returns an error.\n\nWhy this happens: The constraints are contradictory. There is no overlap in the shaded regions. The Feasible Region is empty (\\(F = \\emptyset\\)).\nReal-world Example: ‚ÄúBuild a warehouse that is within 5km of the city center (\\(x \\le 5\\)) AND at least 10km away from residential zones (\\(x \\ge 10\\)).‚Äù It is mathematically impossible to satisfy both.\nDebugging: You must relax (loosen) one or more constraints to find a solution.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  },
  {
    "objectID": "Module-1.html#duality-in-linear-programming",
    "href": "Module-1.html#duality-in-linear-programming",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "2.6 Duality in Linear Programming",
    "text": "2.6 Duality in Linear Programming\n\n2.6.1 The ‚ÄúMirror Image‚Äù of Optimization\nEvery Linear Programming problem (which we call the Primal) has a ghostly twin brother called the Dual.\nIf the Primal problem asks: ‚ÄúHow do I mix these ingredients to make the most profit?‚Äù The Dual problem asks: ‚ÄúHow much are these ingredients actually worth to me?‚Äù\n\n\n2.6.2 Why do Computer Scientists care?\n\nComputational Efficiency: Sometimes the Primal problem has 100,000 constraints and is slow to solve. The Dual might have only 100 constraints and is much faster. Solving the Dual gives you the exact same optimal value (\\(Z^*\\)) as the Primal.\nShadow Prices (Economic Interpretation): The solution values of the Dual variables (\\(y_1, y_2...\\)) tell you the Shadow Price of your resources.\n\nInsight: If the shadow price of ‚ÄúMachine Hours‚Äù is $50, it means acquiring one extra hour of machine time will increase your total profit by exactly $50. This tells managers where to invest!\n\n\n\n\n2.6.3 The Mathematical Transformation\nWe convert a Primal to a Dual by flipping the matrix: * Maximization becomes Minimization. * Right-Hand Side (\\(b\\)) constants of Primal become Objective Coefficients (\\(c\\)) of Dual. * Constraint Matrix (\\(A\\)) is transposed (\\(A^T\\)).\n\n\n2.6.4 Key Theorems\n\nWeak Duality Theorem: The value of any feasible solution to the Maximization problem is always \\(\\le\\) the value of any feasible solution to the Minimization problem. They bound each other.\nStrong Duality Theorem: If the Primal has an optimal solution, the Dual has an optimal solution, and their Objective Values are equal (\\(Z_{primal} = W_{dual}\\)).\n\nEvery LP problem (primal) has a corresponding dual problem:\nPrimal Problem: \\[\n\\begin{aligned}\n\\text{Maximize } & Z = \\mathbf{c}^T\\mathbf{x} \\\\\n\\text{Subject to } & \\mathbf{A}\\mathbf{x} \\leq \\mathbf{b} \\\\\n& \\mathbf{x} \\geq \\mathbf{0}\n\\end{aligned}\n\\]\nDual Problem: \\[\n\\begin{aligned}\n\\text{Minimize } & W = \\mathbf{b}^T\\mathbf{y} \\\\\n\\text{Subject to } & \\mathbf{A}^T\\mathbf{y} \\geq \\mathbf{c} \\\\\n& \\mathbf{y} \\geq \\mathbf{0}\n\\end{aligned}\n\\]\n\n2.6.4.1 Duality Theorems\n\nWeak Duality Theorem: For any feasible solution \\(\\mathbf{x}\\) of primal and \\(\\mathbf{y}\\) of dual: \\[\n\\mathbf{c}^T\\mathbf{x} \\leq \\mathbf{b}^T\\mathbf{y}\n  \\]\nStrong Duality Theorem: If either primal or dual has an optimal solution, then both have optimal solutions and: \\[\n\\mathbf{c}^T\\mathbf{x}^* = \\mathbf{b}^T\\mathbf{y}^*\n  \\]\n\n\n\n\n2.6.5 Sensitivity Analysis\nSensitivity analysis examines how changes in parameters affect the optimal solution:\n\n2.6.5.1 Changes in Objective Function Coefficients\n\nRange of optimality for each coefficient\nEffect on optimal solution when coefficients change\n\n\n\n2.6.5.2 Changes in Right-Hand Side Constants\n\nShadow prices (dual variables)\nRange of feasibility for each constraint\n\n\n\n2.6.5.3 Changes in Constraint Coefficients\n\nEffect of adding new variables or constraints\nImpact of changing technological coefficients\n\n\n\n\n2.6.6 Special Cases in Linear Programming\n\n2.6.6.1 Transportation Problems\nSpecial structure where sources supply destinations with minimum transportation cost.\n\n\n2.6.6.2 Assignment Problems\nSpecial case of transportation problem where each source is assigned to exactly one destination.\n\n\n2.6.6.3 Network Flow Problems\nOptimization problems defined on networks with flow conservation constraints.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  },
  {
    "objectID": "Module-1.html#linear-programming-problems-graphical-method",
    "href": "Module-1.html#linear-programming-problems-graphical-method",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "2.7 Linear Programming Problems ‚Äî Graphical Method",
    "text": "2.7 Linear Programming Problems ‚Äî Graphical Method\nBelow are five LPP problems designed to be solved using the graphical method. For each problem:\n\nDraw each constraint as a straight line in the \\(x_1\\)‚Äì\\(x_2\\) plane.\n\nIdentify the feasible region (including \\(x_1,x_2\\ge0\\)).\n\nFind all corner (vertex) points of the feasible region.\n\nEvaluate the objective \\(Z\\) at each corner to determine the optimum.\n\nState the optimal solution and the optimal value \\(Z^\\star\\).\n\n\nProblem 1 ‚Äî Simple maximization\n\nMaximize \\[\nZ = 3x_1 + 2x_2\n\\]\nSubject to \\[\n\\begin{aligned}\nx_1 + x_2 &\\le 4,\\\\\nx_1 &\\le 3,\\\\\nx_2 &\\le 2,\\\\\nx_1, x_2 &\\ge 0.\n\\end{aligned}\n\\]\n\nProblem 2 ‚Äî Two binding inequalities\n\nMaximize \\[\nZ = 5x_1 + 4x_2\n\\]\nSubject to \\[\n\\begin{aligned}\n2x_1 + x_2 &\\le 8,\\\\\nx_1 + 2x_2 &\\le 8,\\\\\nx_1, x_2 &\\ge 0.\n\\end{aligned}\n\\]\n\nProblem 3 ‚Äî Minimization with intersection corner\n\nMinimize \\[\nZ = 4x_1 + 6x_2\n\\]\nSubject to \\[\n\\begin{aligned}\nx_1 + x_2 &\\ge 4,\\\\\n2x_1 + x_2 &\\ge 6,\\\\\nx_1, x_2 &\\ge 0.\n\\end{aligned}\n\\]\n\nProblem 4 ‚Äî Resource allocation (mix of \\(\\le\\) and \\(\\ge\\))\n\nA factory makes two products \\(P_1\\) and \\(P_2\\) with profits $7 and $5 respectively.\nMaximize profit \\[\nZ = 7x_1 + 5x_2\n\\] Subject to resource limits \\[\n\\begin{aligned}\n3x_1 + 2x_2 &\\le 18 \\quad (\\text{machine-hours}),\\\\\nx_1 + 2x_2 &\\ge 4 \\quad (\\text{minimum production constraint}),\\\\\nx_1, x_2 &\\ge 0.\n\\end{aligned}\n\\]\n\nProblem 5 ‚Äî Problem with a redundant constraint\n\nMaximize \\[\nZ = 2x_1 + 3x_2\n\\]\nSubject to \\[\n\\begin{aligned}\nx_1 + 4x_2 &\\le 12,\\\\\n2x_1 + 8x_2 &\\le 24,\\\\\nx_1 + x_2 &\\le 5,\\\\\nx_1, x_2 &\\ge 0.\n\\end{aligned}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  },
  {
    "objectID": "Module-1.html#practical-implementation-with-python",
    "href": "Module-1.html#practical-implementation-with-python",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "2.8 Practical Implementation with Python",
    "text": "2.8 Practical Implementation with Python\n\nProblem Statement\n\nA Smart City logistics company needs to determine the optimal distribution strategy between two warehouses (Warehouse A and Warehouse B) to minimize total operational costs. The company must decide how many units to ship from each warehouse while considering capacity constraints and transportation costs.\n\n2.8.0.1 Problem Data:\n\nWarehouse A: Transportation cost = $40 per unit\nWarehouse B: Transportation cost = $30 per unit\nConstraint 1: Minimum demand exeeds 60\nConstraint 2: Warehouse A has a maximum capacity of 50\nConstraint 3: Warehouse B has a maximum capacity of 40\nConstraint 4: Total units from both warehouses cannot exceed 200 (2 units from A + 3 unit from B combination)\nBoth warehouses have non-negative shipment quantities\n\n\n\n2.8.1 Mathematical Formulation\n\n2.8.1.1 Decision Variables\nLet: - $ x_1 $: Number of units to ship from Warehouse A - $ x_2 $: Number of units to ship from Warehouse B\n\n\n2.8.1.2 Objective Function\nMinimize the total transportation cost: \\[\n\\text{Minimize } Z = 40x_1 + 30x_2\n\\]\n\n\n\n2.8.2 Complete Linear Programming Model\n\\[\n\\begin{aligned}\n\\text{Minimize } & Z = 40x_1 + 30x_2 \\\\\n\\text{Subject to } & x_1+x_2\\geq 60\\\\\n&x_1\\leq 50\\\\\n&x_2\\leq 40\\\\\n&2x_1 + 3x_2 \\leq 200 \\\\\n& x_1 \\geq 0 \\\\\n& x_2 \\geq 0\n\\end{aligned}\n\\]\n\nUsing PuLP for LP Problems\n\nPuLP provides a high-level interface for formulating and solving optimization problems:\n\nimport pulp\n\n# Create optimization problem\nmodel = pulp.LpProblem(\"Warehouse_Location\", pulp.LpMinimize)\n\n# Define decision variables\nx1 = pulp.LpVariable('Warehouse_A', lowBound=0, cat='Continuous')\nx2 = pulp.LpVariable('Warehouse_B', lowBound=0, cat='Continuous')\n\n# Define objective function\nmodel += 40*x1 + 30*x2, \"Total_Cost\"\n\n# Add realistic constraints\nmodel += x1 + x2 &gt;= 60, \"Minimum_Demand\"\nmodel += x1 &lt;= 50, \"Warehouse_A_Capacity\"  # Warehouse A max capacity\nmodel += x2 &lt;= 40, \"Warehouse_B_Capacity\"  # Warehouse B max capacity\nmodel += 2*x1 + 3*x2 &lt;= 200, \"Budget_Constraint\"  # Combined resource constraint\n\n# Solve the problem\nmodel.solve()\n\n# Print results\nprint(f\"Status: {pulp.LpStatus[model.status]}\")\nprint(f\"Optimal Cost: ${pulp.value(model.objective):.2f}\")\nprint(f\"Warehouse A: {x1.varValue} units\")\nprint(f\"Warehouse B: {x2.varValue} units\")\n\nStatus: Optimal\nOptimal Cost: $2000.00\nWarehouse A: 20.0 units\nWarehouse B: 40.0 units",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  },
  {
    "objectID": "Module-1.html#linear-programming-problems-collection",
    "href": "Module-1.html#linear-programming-problems-collection",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "2.9 Linear Programming Problems Collection",
    "text": "2.9 Linear Programming Problems Collection\n\n2.9.1 Problem 1\nA manufacturing company produces two products (A and B) using three machines (M1, M2, M3). The profit per unit is $50 for product A and $40 for product B. Machine time requirements and availability are given below. Determine the optimal production quantities to maximize profit.\n\n\n\n\n\n\n\n\n\nMachine\nProduct A (hrs/unit)\nProduct B (hrs/unit)\nAvailable Hours\n\n\n\n\nM1\n2\n1\n100\n\n\nM2\n1\n2\n80\n\n\nM3\n1\n1\n60\n\n\n\nMathematical Formulation\nDecision Variables:\n\n\\(x_1\\): Units of Product A to produce\n\\(x_2\\): Units of Product B to produce\n\nObjective Function: \\[\n\\text{Maximize } Z = 50x_1 + 40x_2\n\\]\nConstraints: \\[\n\\begin{aligned}\n2x_1 + x_2 &\\leq 100 \\quad \\text{(Machine M1)} \\\\\nx_1 + 2x_2 &\\leq 80 \\quad \\text{(Machine M2)} \\\\\nx_1 + x_2 &\\leq 60 \\quad \\text{(Machine M3)} \\\\\nx_1, x_2 &\\geq 0\n\\end{aligned}\n\\]\n\nPython Solution\n\n\nimport pulp\n\n# Create the optimization problem\nmodel = pulp.LpProblem(\"Product_Mix_Optimization\", pulp.LpMaximize)\n\n# Decision variables\nx1 = pulp.LpVariable('Product_A', lowBound=0, cat='Continuous')\nx2 = pulp.LpVariable('Product_B', lowBound=0, cat='Continuous')\n\n# Objective function\nmodel += 50*x1 + 40*x2, \"Total_Profit\"\n\n# Constraints\nmodel += 2*x1 + x2 &lt;= 100, \"Machine_M1\"\nmodel += x1 + 2*x2 &lt;= 80, \"Machine_M2\"\nmodel += x1 + x2 &lt;= 60, \"Machine_M3\"\n\n# Solve\nmodel.solve()\n\n# Results\nprint(\"=== PRODUCT MIX OPTIMIZATION ===\")\nprint(f\"Status: {pulp.LpStatus[model.status]}\")\nprint(f\"Optimal Profit: ${pulp.value(model.objective):.2f}\")\nprint(f\"Product A: {x1.varValue} units\")\nprint(f\"Product B: {x2.varValue} units\")\nprint(f\"Machine M1 usage: {2*x1.varValue + x2.varValue}/100 hours\")\nprint(f\"Machine M2 usage: {x1.varValue + 2*x2.varValue}/80 hours\")\nprint(f\"Machine M3 usage: {x1.varValue + x2.varValue}/60 hours\")\n\n=== PRODUCT MIX OPTIMIZATION ===\nStatus: Optimal\nOptimal Profit: $2800.00\nProduct A: 40.0 units\nProduct B: 20.0 units\nMachine M1 usage: 100.0/100 hours\nMachine M2 usage: 80.0/80 hours\nMachine M3 usage: 60.0/60 hours\n\n\n\n\n2.9.2 Problem 2: Diet Problem\nA nutritionist needs to design a minimum-cost diet that meets daily nutritional requirements. Two foods are available with different nutrient contents and costs. Determine the optimal food quantities.\n\n\n\n\n\n\n\n\n\nNutrient\nFood 1 (units/kg)\nFood 2 (units/kg)\nMinimum Daily Requirement\n\n\n\n\nProtein\n2\n1\n8 units\n\n\nCarbs\n1\n2\n10 units\n\n\nFat\n1\n1\n6 units\n\n\nCost ($)\n3\n2\n-\n\n\n\nMathematical Formulation\n\nDecision Variables:\n\n\n\\(x_1\\): kg of Food 1 to include in daily diet\n\\(x_2\\): kg of Food 2 to include in daily diet\n\n\nObjective Function:\n\nMinimize the total daily cost: \\[\n\\text{Minimize } Z = 3x_1 + 2x_2\n\\]\n\nConstraints:\n\nProtein Requirement: \\[\n2x_1 + x_2 \\geq 8\n\\]\nCarbohydrates Requirement: \\[\nx_1 + 2x_2 \\geq 10\n\\]\nFat Requirement: \\[\nx_1 + x_2 \\geq 6\n\\]\nNon-negativity Constraints: \\[\nx_1 \\geq 0, \\quad x_2 \\geq 0\n\\]\nComplete Linear Programming Model\n\\[\n\\begin{aligned}\n\\text{Minimize } & Z = 3x_1 + 2x_2 \\\\\n\\text{Subject to } & 2x_1 + x_2 \\geq 8 \\\\\n& x_1 + 2x_2 \\geq 10 \\\\\n& x_1 + x_2 \\geq 6 \\\\\n& x_1 \\geq 0 \\\\\n& x_2 \\geq 0\n\\end{aligned}\n\\]\n\nPython Implementation\n\n\nimport pulp\n\n# Create the optimization problem\nmodel = pulp.LpProblem(\"Diet_Problem\", pulp.LpMinimize)\n\n# Define decision variables\nx1 = pulp.LpVariable('Food_1', lowBound=0, cat='Continuous')\nx2 = pulp.LpVariable('Food_2', lowBound=0, cat='Continuous')\n\n# Define objective function (minimize cost)\nmodel += 3*x1 + 2*x2, \"Total_Cost\"\n\n# Add nutritional constraints\nmodel += 2*x1 + x2 &gt;= 8, \"Protein_Requirement\"\nmodel += x1 + 2*x2 &gt;= 10, \"Carbohydrates_Requirement\"\nmodel += x1 + x2 &gt;= 6, \"Fat_Requirement\"\n\n# Solve the problem\nmodel.solve()\n\n# Display results\nprint(\"=== DIET PROBLEM OPTIMIZATION ===\")\nprint(f\"Solution Status: {pulp.LpStatus[model.status]}\")\nprint(f\"Minimum Daily Cost: ${pulp.value(model.objective):.2f}\")\nprint(f\"Optimal Food Quantities:\")\nprint(f\"  Food 1: {x1.varValue:.2f} kg\")\nprint(f\"  Food 2: {x2.varValue:.2f} kg\")\n\n# Verify nutritional intake\nprint(f\"\\nNutritional Analysis:\")\nprint(f\"Protein Intake: {2*x1.varValue + x2.varValue:.1f} units (Minimum: 8 units)\")\nprint(f\"Carbohydrates Intake: {x1.varValue + 2*x2.varValue:.1f} units (Minimum: 10 units)\")\nprint(f\"Fat Intake: {x1.varValue + x2.varValue:.1f} units (Minimum: 6 units)\")\n\n# Cost breakdown\nprint(f\"\\nCost Breakdown:\")\nprint(f\"Food 1 Cost: ${3*x1.varValue:.2f}\")\nprint(f\"Food 2 Cost: ${2*x2.varValue:.2f}\")\nprint(f\"Total Cost: ${pulp.value(model.objective):.2f}\")\n\n=== DIET PROBLEM OPTIMIZATION ===\nSolution Status: Optimal\nMinimum Daily Cost: $14.00\nOptimal Food Quantities:\n  Food 1: 2.00 kg\n  Food 2: 4.00 kg\n\nNutritional Analysis:\nProtein Intake: 8.0 units (Minimum: 8 units)\nCarbohydrates Intake: 10.0 units (Minimum: 10 units)\nFat Intake: 6.0 units (Minimum: 6 units)\n\nCost Breakdown:\nFood 1 Cost: $6.00\nFood 2 Cost: $8.00\nTotal Cost: $14.00",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  },
  {
    "objectID": "Module-1.html#micro-project-1-campus-city-emergency-supply-distribution",
    "href": "Module-1.html#micro-project-1-campus-city-emergency-supply-distribution",
    "title": "2¬† Module 1: Basics of Optimization and Linear Programming",
    "section": "2.10 Micro-Project 1: Campus City Emergency Supply Distribution",
    "text": "2.10 Micro-Project 1: Campus City Emergency Supply Distribution\nAs an optimization analyst at Campus City Logistics, you‚Äôve been tasked with designing the optimal supply distribution network for essential resources across campus facilities. The current ad-hoc system is inefficient and costly.\n\n2.10.1 Problem Statement\nDetermine the optimal warehouse locations and distribution plan that minimizes total annual costs while meeting all facility demands, respecting warehouse capacity constraints, and operating within the allocated budget.\n\n\n2.10.2 Facilities Data (From facilities.csv)\nBased on our dataset, we have 15 facilities with the following key attributes:\nCritical Facilities Selected for Micro-Project 1:\n\n\n\nFacility ID\nFacility Name\nType\nDaily Demand\n\n\n\n\nMED_CENTER\nCampus Medical Center\nHospital\n80 units\n\n\nENG_BUILDING\nEngineering Building\nAcademic\n30 units\n\n\nSCIENCE_HALL\nScience Hall\nAcademic\n35 units\n\n\nDORM_A\nNorth Dormitory\nResidential\n55 units\n\n\nDORM_B\nSouth Dormitory\nResidential\n45 units\n\n\nLIBRARY\nMain Library\nAcademic\n25 units\n\n\n\nTotal Daily Demand: 270 units\n\n\n2.10.3 Warehouse Data (From warehouses.csv)\n\n\n\n\n\n\n\n\n\n\nWarehouse ID\nWarehouse Name\nDaily Capacity\nConstruction Cost\nOperational Cost/Day\n\n\n\n\nWH_NORTH\nNorth Campus Warehouse\n400 units\n$300,000\n$800\n\n\nWH_SOUTH\nSouth Campus Warehouse\n350 units\n$280,000\n$700\n\n\nWH_EAST\nEast Gate Warehouse\n450 units\n$320,000\n$900\n\n\n\nTotal Available Capacity: 1,200 units\n\n\n2.10.4 Transportation Costs (From transportation_costs.csv)\n\nData Source: Pre-calculated matrix with actual distances\nCost Range: $3.68 - $5.03 per unit between selected locations\nCalculation: Based on real geographic coordinates using Haversine formula\n\n\n\n2.10.5 Financial Constraints\n\nAnnual Budget: $1,500,000\nOperational Period: 365 days (annual calculation)\nConstruction Cost: Amortized over 10 years\nAll costs must be annualized\n\n\n\n2.10.6 Physical & Business Constraints\n\nWarehouse Selection: Select exactly 2 warehouses for redundancy\nDemand Satisfaction: Each facility must receive exactly its daily demand √ó 365\nCapacity Limits: Shipments from each warehouse ‚â§ capacity √ó 365\nBudget Limit: Total annual cost ‚â§ $1,500,000\nNon-negativity: All shipment quantities ‚â• 0\n\n\n\n2.10.7 Learning Objectives\nTechnical Skills\n\nFormulate Mixed-Integer Linear Programming (MILP) problem\nImplement optimization model using PuLP\nHandle real geographic and cost data\nValidate constraint satisfaction\n\nAnalytical Skills\n\nInterpret optimization results in business context\nAnalyze cost breakdown and efficiency metrics\nProvide actionable recommendations\n\nProject Deliverables\n\nDeliverable 1: Mathematical Formulation (3 Marks)\nDeliverable 2: Report in .pdf format (7 Marks)",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Module 1: Basics of Optimization and Linear Programming</span>"
    ]
  }
]